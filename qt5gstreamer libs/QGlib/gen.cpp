// Autogenerated by the QtGStreamer helper code generator - DO NOT EDIT
/*
    Copyright (C) 2010 George Kiagiadakis <kiagiadakis.george@gmail.com>
    Copyright (C) 2010 Collabora Ltd.
      @author George Kiagiadakis <george.kiagiadakis@collabora.co.uk>

    This library is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published
    by the Free Software Foundation; either version 2.1 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#define INCLUDED_FROM_CODEGEN
#include <boost/static_assert.hpp>

#define REGISTER_TYPE_IMPLEMENTATION(T, GTYPE) \
    namespace QGlib { \
        GetTypeImpl<T>::operator Type() { return (GTYPE); } \
    }

#include <glib-object.h>
#include "QGlib/string_p.h"

#include "QGlib/qglib_signal.h"

namespace QGlib {
    BOOST_STATIC_ASSERT(static_cast<int>(Signal::RunFirst) == static_cast<int>(G_SIGNAL_RUN_FIRST));
    BOOST_STATIC_ASSERT(static_cast<int>(Signal::RunLast) == static_cast<int>(G_SIGNAL_RUN_LAST));
    BOOST_STATIC_ASSERT(static_cast<int>(Signal::RunCleanup) == static_cast<int>(G_SIGNAL_RUN_CLEANUP));
    BOOST_STATIC_ASSERT(static_cast<int>(Signal::NoRecurse) == static_cast<int>(G_SIGNAL_NO_RECURSE));
    BOOST_STATIC_ASSERT(static_cast<int>(Signal::Detailed) == static_cast<int>(G_SIGNAL_DETAILED));
    BOOST_STATIC_ASSERT(static_cast<int>(Signal::Action) == static_cast<int>(G_SIGNAL_ACTION));
    BOOST_STATIC_ASSERT(static_cast<int>(Signal::NoHooks) == static_cast<int>(G_SIGNAL_NO_HOOKS));
}

#include "QGlib/paramspec.h"

REGISTER_TYPE_IMPLEMENTATION(QGlib::ParamSpec,G_TYPE_PARAM)

REGISTER_TYPE_IMPLEMENTATION(QGlib::ParamSpec::ParamFlags,G_TYPE_PARAM_FLAGS)

namespace QGlib {
  QGlib::RefCountedObject *ParamSpec_new(void *instance)
  {
    QGlib::ParamSpec *cppClass = new QGlib::ParamSpec;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QGlib

namespace QGlib {
    BOOST_STATIC_ASSERT(static_cast<int>(ParamSpec::Readable) == static_cast<int>(G_PARAM_READABLE));
    BOOST_STATIC_ASSERT(static_cast<int>(ParamSpec::Writable) == static_cast<int>(G_PARAM_WRITABLE));
    BOOST_STATIC_ASSERT(static_cast<int>(ParamSpec::ReadWrite) == static_cast<int>(G_PARAM_READWRITE));
    BOOST_STATIC_ASSERT(static_cast<int>(ParamSpec::Construct) == static_cast<int>(G_PARAM_CONSTRUCT));
    BOOST_STATIC_ASSERT(static_cast<int>(ParamSpec::ConstructOnly) == static_cast<int>(G_PARAM_CONSTRUCT_ONLY));
    BOOST_STATIC_ASSERT(static_cast<int>(ParamSpec::LaxValidation) == static_cast<int>(G_PARAM_LAX_VALIDATION));
    BOOST_STATIC_ASSERT(static_cast<int>(ParamSpec::Deprecated) == static_cast<int>(G_PARAM_DEPRECATED));
}

#include "QGlib/global.h"

#include "QGlib/value.h"

REGISTER_TYPE_IMPLEMENTATION(QGlib::Value,G_TYPE_VALUE)

#include "QGlib/object.h"

REGISTER_TYPE_IMPLEMENTATION(QGlib::Object,G_TYPE_OBJECT)

REGISTER_TYPE_IMPLEMENTATION(QGlib::Interface,G_TYPE_INTERFACE)

namespace QGlib {
  QGlib::RefCountedObject *Object_new(void *instance)
  {
    QGlib::Object *cppClass = new QGlib::Object;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QGlib

namespace QGlib {
  QGlib::RefCountedObject *Interface_new(void *instance)
  {
    QGlib::Interface *cppClass = new QGlib::Interface;
    cppClass->m_object = instance;
    return cppClass;
  }
} //namespace QGlib

#include "QGlib/error.h"

REGISTER_TYPE_IMPLEMENTATION(QGlib::Error,G_TYPE_ERROR)

#include "QGlib/type.h"

REGISTER_TYPE_IMPLEMENTATION(QGlib::Type,G_TYPE_GTYPE)

namespace QGlib {
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Invalid) == static_cast<int>(G_TYPE_INVALID));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::None) == static_cast<int>(G_TYPE_NONE));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Interface) == static_cast<int>(G_TYPE_INTERFACE));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Char) == static_cast<int>(G_TYPE_CHAR));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Uchar) == static_cast<int>(G_TYPE_UCHAR));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Boolean) == static_cast<int>(G_TYPE_BOOLEAN));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Int) == static_cast<int>(G_TYPE_INT));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Uint) == static_cast<int>(G_TYPE_UINT));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Long) == static_cast<int>(G_TYPE_LONG));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Ulong) == static_cast<int>(G_TYPE_ULONG));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Int64) == static_cast<int>(G_TYPE_INT64));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Uint64) == static_cast<int>(G_TYPE_UINT64));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Enum) == static_cast<int>(G_TYPE_ENUM));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Flags) == static_cast<int>(G_TYPE_FLAGS));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Float) == static_cast<int>(G_TYPE_FLOAT));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Double) == static_cast<int>(G_TYPE_DOUBLE));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::String) == static_cast<int>(G_TYPE_STRING));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Pointer) == static_cast<int>(G_TYPE_POINTER));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Boxed) == static_cast<int>(G_TYPE_BOXED));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Param) == static_cast<int>(G_TYPE_PARAM));
    BOOST_STATIC_ASSERT(static_cast<int>(Type::Object) == static_cast<int>(G_TYPE_OBJECT));
}

#include "QGlib/quark.h"

#include "QGlib/refpointer.h"

#include "QGlib/connect.h"


#include "QGlib/init.h"

#include "QGlib/wrap.h"

namespace QGlib {
namespace Private {
  void registerWrapperConstructors()
  {
    QGlib::Quark q = g_quark_from_static_string("QGlib__wrapper_constructor");
    QGlib::GetType<ParamSpec>().setQuarkData(q, reinterpret_cast<void*>(&ParamSpec_new));
    QGlib::GetType<Object>().setQuarkData(q, reinterpret_cast<void*>(&Object_new));
    QGlib::GetType<Interface>().setQuarkData(q, reinterpret_cast<void*>(&Interface_new));
  }
} //namespace Private
} //namespace QGlib

